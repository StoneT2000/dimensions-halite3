import { Match, agentID, MatchStatus, LoggerLEVEL } from "..";
/**
 * @class Design
 * @classdesc Abstract class detailing a `Design` to be used as the platform that holds competition runtime logic for
 * updating and manipulating ongoing `matches`
 *
 * Refer to `Match` class for exposed fields available for user's use. User's can also extend the `Match` class and add
 * more fields if they wish for their own use and pass their own `Match` class instantiations
 *
 */
export declare abstract class Design {
    name: String;
    designOptions: DesignOptions;
    private log;
    constructor(name: String, designOptions?: Partial<DesignOptions>);
    _setLogLevel(level: LoggerLEVEL): void;
    /**
     * Get the design options associated with this `Design`
     */
    getDesignOptions(): DesignOptions;
    /**
     *
     * @param match - The `Match` to initialize state with
     * @param config - Any user configurations that can be added as parameters
     * @returns true if initialized correctly
     */
    abstract initialize(match: Match, config?: any): Promise<void>;
    /**
     * Abstract function required to update `match` state with commands from Agents and send commands to Agents
     * along with returning the current match status, one of which can be MatchStatus.FINISHED
     * This function is used by the `match` to update the `match` state
     *
     * @param match - The `Match` to update state with `Commands`
     * @param commands - The `Commands` used to update the state in a `Match`
     * @param config - Any user configurations that can be added as parameters
     */
    abstract update(match: Match, commands: Array<Command>, config?: any): Promise<MatchStatus>;
    /**
     * Abstract function required to get the result of a `match`
     * This function is used by the `match` to update the results stored in the `match` and return results
     *
     * @param match - The `Match` used to process results
     * * @param config - Any user configurations that can be added as parameters
     */
    abstract getResults(match: Match, config?: any): Promise<any>;
}
export declare enum COMMAND_STREAM_TYPE {
    PARALLEL = 0,
    SEQUENTIAL = 1
}
export declare type CommandSequence = {
    commands: Array<string>;
    agentID: agentID;
};
export declare type Command = {
    command: string;
    agentID: agentID;
};
export declare type DesignOptions = {
    commandStreamType: COMMAND_STREAM_TYPE;
    commandDelimiter: string;
};
