"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var __1 = require("..");
var fs = require('fs');
var AgentStatus;
(function (AgentStatus) {
    AgentStatus[AgentStatus["UNINITIALIZED"] = 0] = "UNINITIALIZED";
    AgentStatus[AgentStatus["READY"] = 1] = "READY";
    AgentStatus[AgentStatus["RUNNING"] = 2] = "RUNNING";
    AgentStatus[AgentStatus["CRASHED"] = 3] = "CRASHED";
    AgentStatus[AgentStatus["KILLED"] = 4] = "KILLED";
})(AgentStatus = exports.AgentStatus || (exports.AgentStatus = {}));
/**
 * @class Agent
 * @classdesc Reads in a file source for the code and creates an `Agent` for use in the `MatchEngine` and `Match`
 */
var Agent = /** @class */ (function () {
    function Agent(file, options) {
        this.id = 0;
        this.process = null;
        this.status = AgentStatus.UNINITIALIZED;
        this.currentMoveCommands = [];
        this.currentMoveResolve = function () { }; // set as a dummy function
        this.agentTimeStep = 0;
        this.log = new __1.Logger();
        this.creationDate = new Date();
        this.src = file;
        var ext = this.src.slice(-3);
        switch (ext) {
            case '.py':
                this.cmd = 'python';
                break;
            case '.js':
                this.cmd = 'node';
                break;
            default:
            // throw new DimensionError(`${ext} is not a valid file type`);
        }
        // check if file exists
        if (!fs.existsSync(file)) {
            throw new __1.FatalError(file + " does not exist, check if file path provided is correct");
        }
        if (options.command) {
            this.cmd = options.command;
        }
        else if (!this.cmd) {
            throw new __1.FatalError("No command provided or inferable for agent using " + file);
        }
        if (options.id !== undefined) {
            this.id = options.id;
        }
        else {
            throw new __1.FatalError("No id provided for agent using " + file);
        }
        if (options.name) {
            this.name = options.name;
        }
        else {
            this.name = "agent_" + this.id;
        }
        this.log.level = options.loggingLevel;
        this.log.system("Created agent: " + this.name);
        this.status = AgentStatus.READY;
        // initialize promise functions
        // this.currentMoveCommands = [];
        // this.currentMovePromise = new Promise((resolve, reject) => {
        //   this.currentMoveResolve = resolve;
        //   this.currentMoveReject = reject;
        // });
    }
    // Start an Agent's move and setup the promise structures
    Agent.prototype._setupMove = function () {
        var _this = this;
        // continue agent again
        this.process.kill('SIGCONT');
        this.agentTimeStep++;
        this.currentMoveCommands = [];
        this.currentMovePromise = new Promise(function (resolve, reject) {
            _this.currentMoveResolve = resolve;
            _this.currentMoveReject = reject;
        });
    };
    /**
     * Generates a list of agents for use
     * @param files List of files to use to make agents
     * @param names List of optional names for each agent, if empty, defaults to default agent names
     */
    Agent.generateAgents = function (files, loggingLevel) {
        var agents = [];
        if (typeof files[0] === 'string') {
            files.forEach(function (file, index) {
                agents.push(new Agent(file, { id: index, name: undefined, loggingLevel: loggingLevel }));
            });
        }
        else {
            files.forEach(function (info, index) {
                agents.push(new Agent(info.file, { id: index, name: info.name, loggingLevel: loggingLevel }));
            });
        }
        return agents;
    };
    return Agent;
}());
exports.Agent = Agent;
//# sourceMappingURL=index.js.map