import { Agent, Design, agentID, LoggerLEVEL } from '..';
export declare enum MatchStatus {
    UNINITIALIZED = 0,
    READY = 1,
    RUNNING = 2,
    STOPPED = 3,
    FINISHED = 4,
    ERROR = 5
}
export declare type MatchConfigs = {
    name?: any;
    timeout?: number;
    initializeConfig?: any;
    updateConfig?: any;
    storeResultConfig?: any;
    loggingLevel?: LoggerLEVEL;
    dimensionID?: number;
    [key: string]: any;
};
/**
 * @class Match
 * @classdesc An match created using a `Design` and a list of `Agents`. The match can be started and stopped, and
 * statistics can be retrieved at any point in time. This can be extended if needed
 * @param design - The `Design` used
 * @param agents - List of agents used to create Match.
 * @param configs - Configurations that are passed to every run through initialize, update, and storeResults in the
 * given `Design`
 */
export declare class Match {
    design: Design;
    agentFiles: Array<String> | Array<{
        file: string;
        name: string;
    }>;
    configs: MatchConfigs;
    creationDate: Date;
    name: string;
    id: number;
    dimensionID: number;
    private static _id;
    state: any;
    agents: Array<Agent>;
    idToAgentsMap: Map<agentID, Agent>;
    timeStep: number;
    private matchEngine;
    private log;
    results: any;
    matchStatus: MatchStatus;
    constructor(design: Design, agentFiles: Array<String> | Array<{
        file: string;
        name: string;
    }>, configs?: MatchConfigs);
    /**
     * Initializes using this config dependeing on how `Design's` `initialize` is implemented
     * @param config - Configurations for initializtion
     * @returns a promise that resolves true/false if initialized correctly
     */
    initialize(): Promise<boolean>;
    /**
     * Runs this match to completion. Resolves / returns the match results when done
     */
    run(): Promise<any>;
    /**
     * Next function. Moves match forward by one timestep. Resolves with the match status
     */
    next(): Promise<MatchStatus>;
    /**
     * Stops at the nearest timestep available
     *
     * Notes:
     * - If design uses a PARALLEL match engine, stopping behavior can be a little unpredictable
     * - If design uses a SEQUENTIAL match engine, a stop will result in ensuring all agents complete all their actions up
     *   to a coordinated stopping `timeStep`
     */
    stop(): Promise<void>;
    stopAndCleanUp(): Promise<void>;
    getResults(): Promise<unknown>;
    sendAll(message: string): Promise<unknown>;
    /**
     * Functional method for sending a message string to a particular agent. Returns a promise that resolves true if
     * succesfully sent
     * @param message
     * @param receiver - receiver of message can be specified by the `Agent` or it's agentID (a number)
     */
    send(message: string, receiver: Agent | agentID): Promise<unknown>;
    /**
     * Throw an error within the `Match`, indicating an Agent tried a command that was forbidden in the match according
     * to a `Design`
     * Examples are misuse of an existing command or using incorrect commands
     * @param agentID - the misbehaving agent's ID
     * @param error - The error
     */
    throw(agentID: agentID, error: Error): Promise<void>;
}
