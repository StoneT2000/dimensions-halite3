import { Design, Agent, agentID, LoggerLEVEL, Match, COMMAND_STREAM_TYPE, Command } from "..";
export declare enum IO_COMMANDS {
    MOVE_FNISH = "D_FINISH",
    MOVE_START = "D_START"
}
export declare type EngineOptions = {
    commandStreamType: COMMAND_STREAM_TYPE;
    commandDelimiter: string;
};
/**
 * @class MatchEngine
 * @classdesc The Match Engine that takes a `Design` and starts matches by spawning new processes for each `Agent`
 * It returns results while a game is running and returns final results as well. Can start and stop the engine
 * Functionally runs matches as storing the match causes circular problems
 * (previously Match has Engine, Engine has Match)
 */
export declare class MatchEngine {
    private design;
    engineOptions: EngineOptions;
    private log;
    constructor(design: Design, loggingLevel: LoggerLEVEL);
    setLogLevel(loggingLevel: LoggerLEVEL): void;
    /**
     * Starts up the engine by intializing processes for all the agents and setting some variables for a match
     * @param agents
     */
    initialize(agents: Array<Agent>, match: Match): Promise<boolean>;
    stop(): Promise<void>;
    killAndClean(match: Match): Promise<void>;
    /**
     * Returns a promise that resolves with all the commands loaded from the previous time step of the provided match
     * This coordinates all the Agents and waits for each one to finish their step
     */
    getCommands(match: Match): Promise<Array<Command>>;
    send(match: Match, message: string, id: agentID): Promise<unknown>;
}
